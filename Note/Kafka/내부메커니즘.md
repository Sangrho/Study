## 내부 메커니즘
아래 세 가지 초점으로 살펴본다.
- 카프카 복제가 동작하는 방법
- 카프카가 프로듀서와 컨슈머의 요청을 처리하는 방법
- 카프카가 스토리지(예를 들어, 파일 형식이나 인덱스)를 처리하는 방법

### 클러스터 멤버십

내부적으로 주키퍼는 표준 파일 시스템의 디렉터리처럼 계층적인 트리 구조로 데이터를 저장하고 사용한다.
그리고 데이터를 저장하는 노드를 znode라고 하며, 각 znode의 이름 앞에는 / 를 붙이고 디렉터리처럼 경로를 사용해서 각 노드의 위치를 식별한다.
각 노드에는 상태와 구성 정보 및 위치 정보 등의 데이터만 저장되므로 크기가 작으며(1KB 미만), 모든 노드가 메모리에 저장되어 처리되므로 속도라 빠르다.
그리고 임시(ephemeral) 노드와 영구(persistent) 노드로 구분된다.
임시 노드는 노드를 생성한 클라이언트가 연결되어 있을 때만 존재하며,
연결이 끊어지면 자동으로 삭제된다. 반면 영구 노드는 클라이언트가 삭제하지 않는한 계속 보존된다.</br></br>
카프카에서도 주키퍼를 사용해서 클러스터 멤버인 브로커들의 메타데이터를 유지 관리한다.
예를 들어 아래와 같다</br>

    /kafka-main/brokers : 브로커 관련 정보 저장
    /kafka-main/brokers/ids : 브로커 ID 저장
    /kafka-main/topics : 토픽 정보가 저장
    /kafka-main/config : 토픽의 설정 정보가 저장
    /kafka-main/consumers : 컨슈머의 파티션 오프셋 정보를 저장(0.9 버전부터 __consumer_offsets topic 에 저장되도록 변경됨)

모든 카프카 브로커는 고유 식별자를 가지며, 이것은 브로커의 구성 파일에 설정되거나 자동으로 생성된다.
브로커 프로세스는 시작될 때마다 주키퍼의 /brokers/id 에 임시 노드로 자신의 ID를 등록한다.
만일 같은 ID 를 갖는 다른 브로커를 시작하려고 하면 같은 주키퍼 노드가 이미 있으므로 에러가 발생한다.</br></br>
그리고 브로커 구성에서 브로커가 추가 혹은 삭제되거나 주키퍼와 연결이 끊어지면, 해당 브로커가 시작될 때 생성되었던 임시노드는 자동으로 주키퍼에서 삭제되며,
브로커 내역을 모니터링하는 카프카 컴포넌트들이 알 수 있다.(주키퍼의 Watch 설정)</br></br>
브로커가 중단되면 해당 브로커의 주키퍼 노드는 삭제된다. 그러나 해당 브로커의 ID는 여전히 다른 데이터 구조에 존재한다. 

### 컨트롤러

컨트롤러는 카프카 브로커 중 하나이며, 일반 브로커의 기능에 추가하여 파티션 리더를 선출하는 책임을 갖는다. 
클러스터에서 시작하는 첫 번째 브로커가 컨트롤러가 되며, 이 브로커는 주키퍼의 임시 노드인 /controller를 생성한다.
그리고 다른 브로커들이 시자고딜 때도 /controller 노드를 생성하려고 시도한다.
그러나 '노드가 이미 존재한다' 는 예외를 받으므로,
이미 /controller 노드가 있고 클러스터에도 컨트롤러가 있다는 것을 '알게된다'.
그리고 모든 브로커들은 /controller 노드에 주키퍼의 Watch를 생성하므로 이 노드에 변경이 생기는 것을 알 수 있다.
이런 방법을 통해서 클러스터에는 항상 하나의 컨트롤러만 존재한다.</br></br>
컨트롤러 브로커가 중단되거나 주키퍼와의 연결이 끊어지면 임시 노드인 /controller가 삭제된다.
이때 해당 클러스터의 다른 브로커들이 주키퍼의 Watch를 통해 그 사실을 알게 되고 /controller 노드의 생성을 시도한다.
그리고 그 노드를 첫 번째로 생성한 브로커가 컨트롤러가 되며, 다른 브로커들은 이미 얘기한 대로 '노드가 이미 존재한다'는 예외를 받는다.
또한 모든 브로커가 새소 생성된 /controller 노드에 주키퍼의 Watch를 생성한다.
컨트롤러는 매번 새로 선출될 때마다 주키퍼로부터 새로운 컨트롤러 세대 번호를 받으며,
나머지 브로커들은 현재의 컨트롤러 세대 번호를 알게 된다.
따라서 변경 전의 컨트롤러와 혼동되지 않으며, 이전 세대 번호로 된 컨트롤러 메세지를 받으며 무시한다.</br></br>
관련 주키퍼 경로를 Watch하여 특정 브로커가 클러스터를 떠났다는 것을 컨트롤러가 인지하면, 그 브로커가 리더로 할당되었던 모든 파티션들에
새로운 리더가 필요하다는 것을 알게 된다. 그 다음에 컨트롤러는 새로운 리더를 필요로 하는 모든 파티션들을 점검하고 새로 리더가 될 브로커를 결정한다.(간단히 해당 파티션의 리플리카 리스트에서 그 다음 순서의 브로커로 겨렂ㅇ함).
그리고 컨트롤러는 파티션들의 새로운 리더들과 팔로워들의 정보를 모든 브로커들에게 전송한다.


### 복제

### 요청 처리

#### 쓰기 요청

#### 읽기 요청

#### 기타 요청


### 스토리지

#### 파티션 할당

#### 파일 관리
#### 파일 형식

#### 인덱스

#### 압축

#### 압축 처리 방법

#### 삭제된 메세지

#### 토픽은 언제 압축될까?


Referenced from Kafka The definitive guide
