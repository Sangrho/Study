### CHAPTER 18 모니터링과 디버깅   
#### 18.1 모니터링 범위   
모니터링 대상 포인트는 아래와 같다.  
- 스파크 애플리케이션 & 잡  
	가장 먼저 스파크 WEB UI 와 로그를 확인한다.  
	이 두 가지는 애플리케이션의 RDD 와 쿼리 실행 계획같은 개념적 수준의 정보를 제공한다.  
- JVM  
	익스큐터는 모두 개별 JVM 에서 실행되기 때문에, jstack, jmap, jstat, jconsole 등으로 JVM 에 대한 모니터링이 필요하다.  
- OS  
	-dstat, iostat, iotop 같은 명령어로 CPU, 네트웤, I/O 등의 자원에 대해 모니터링이 필요하다.  
- Cluster  
  
![image](https://user-images.githubusercontent.com/4033129/79685492-3843b500-8274-11ea-926c-7898482249c6.png)  
  
#### 18.2 모니터링 대상   
모니터링 대상은 크게 두 가지로 나뉠 수 있다.  
1. 실행 중인 사용자 애플리케이션의 프로세스(CPU, 메모리 사용률 등)  
2. 프로세스 내부에서의 쿼리 실행 콰정(잡, 테스트)  
  
##### 18.2.1 드라이버와 익스큐터 프로세스  
드라이버를 모니터링하게 되면, 모든 애플리케이션의 상태를 볼 수 있고 안정적으로 실행 중인지 확인할 수 있다.  
이 외에 스파크 자체적으로 제공하는 메트릭은 `metrics.properties` 파일을 수정하여 사용할 수 있다.  
이 부분은 JMV Exporter 로 활용할 때 자세히 찾아본다.  
Reference : https://notes.elmiko.dev/2016/08/25/spark-metrics-with-graphite.html  
  
#### 18.3 스파크 로그   
#### 18.4 스파크 UI   
#### 18.5 디버깅 및 스파크 응급 처치   
##### 18.5.1 스파크 애플리케이션이 시작되지 않는 경우  
- 애플리케이션 실행에 필요한 자원을 적절하게 설정하지 않았을 경우 발생  
- 드라이버와 익스큐터 간 통신이 제대로 이루어지지 않았을 경우 발생   
  
##### 18.5.2 스파크 애플리케이션 실행 전에 오류가 발생하는 경우  
- 코드 상의 문제일 수 있으니 디버깅용 로그를 포진한다.  
- 드라이버, 워커, 저장소 간의 네트워크 연결 상태 확인  
- 데이터셋을 하나만 읽도록 변경해서 하나씩 디버깅  
  
##### 18.5.3 스파크 애플리케이션 실행 중에 오류가 발생한 경우  
- 데이터가 존재하는지, 데이터가 올바른 포맷인지 확인  
- 쿼리에 잘못된 컬럼명을 입력했을 수 있다.  
- 어떤 컴포넌트와 연관되어 있는지 Stack trace 로 확인한다.  
- 입력 데이터와 데이터 포맷을 확인한다.  
- 잡의 테스크가 잠시 실행되다가 비정상적으로 종료된다면 입력데이터 자체의 문제일 수 있다. 예를 들어 null 처리!  
  
##### 18.5.4 느리거나 뒤처진 테스크  
대부분 DF, RDD 파티션에 데이터가 균등하게 분할되지 않는 경우에 발생한다.  
이럴 경우 일부 익스큐터가 다른 익스큐터에 비해 훨씬 더 많은 양의 데이터를 처리하게 된다.  
- 파티션별 데이터양을 줄이기 위해 파티션 수를 증가시켜 본다.  
- 다른 컬럼을 조합해 파티션을 재분배한다. 예를 들어 데이터 스큐가 심한 ID 컬럼을 파티셔닝하거나, 컬럼에서 많은 값이 null dㅣ라면 느린테스크가 발생할 수 있다. 따라서 null 값을 먼저 필터링하는 것도 좋다.  
- 가능한한 익스큐터의 메모리를 증가시킨다.  
- 특정 머신에 디스크 용량 확인( 이는 에러로그로 확인 가능 )  
- Dataset 은 레코드를 사용자 정의 함수와 자바 객체로 변환하기 위해 수많은 객체를 생성하므로 GC 가 빈번히 일어날 수 있다.   
  
##### 18.5.5 느린 집계 속도  
- 집계 연산 전에 파티션 수를 증가시키면 태스크별로 처리할 키 수를 줄일 수 있다.  
- 익스큐터의 메모리를 증가시킨다.  
- 집계 처리가 끝나고 이어서 실행되는 테스크가 느리다면 집계 처리된 데이터 셋에 불균형 현상이 남아있는 것이다. 이 경우 파티션을 임의로 재분배할 수 있도록 `reparititon` 명령을 사용한다.  
- 스파크는 잡 실행 전에 null 값을 건너뛰기 위한 최적화를 하게 되는데, null 표현이 다른지 확인한다.  
  
##### 18.5.6 느린 조인 속도  
- 조인이 여러개라면 순서를 바꿔보면서 수행해본다.  
- 조인을 수행하기 전에 데이터셋을 분할하면 클러스터 노드 간 데이터 이동을 줄일 수 있따. 특히 도일한 데이터 셋이 여러 조인 연산에서 사용된다면 더욱 유용하다. 또한 다양한 사전 조인 파티셔닝 기법을 도입해 본다. (조인되는 테이블을 하나로 결합해 데이터를 분할하는 방식)  
- 조인 연산을 줄이기 위해 필요한 컬럼만 골라서 하는 방법도 있다.  
- DF 나 테이블에 대한 통계가 없는 경우 브로드캐스트 조인을 사용하는 실행 계획을 생성하지 못한다. 조인 대상 테이블 중 하나가 작은 경우 강제로 브로드캐스트하거나 스파크의 통계 수집 명령을 사용해 테이블을 분석한다. (Reference : https://docs.databricks.com/spark/latest/spark-sql/language-manual/analyze-table.html)  
  
##### 18.5.7 느린 읽기와 쓰기 속도  
- spark.epculation 속성을 사용해본다. 첫 번째 태스크에서 발생한 문제가 일시적인지 확인하기 위해 동일하 ㄴ연산ㅇ르 수행하는 태스크를 추가로 실행한다. 하지만 데이터 중복이나 일관성이 중요한 작업에 대해서는 사용하지 않는다.  
- 네트어크 대역폭이 충분하지 않을 수 있다.  
- Spark locality 를 고려해 본다.  
  
##### 18.5.8 드라이버 OOM 또는 응답 없음  
- 코드에서 collect 함수 주변을 살펴 본다.  
- 브로드캐스트 하기에 너무 큰 데이터를 사용했을 수 있다.  
- 장시간 실행되는 앱의 드라이버에 많은 양의 객체를 생성한 이후로 해제하지 못할 수 있다. 이를 확인해 본다.  
- 파이썬, 자바 등 여러 언어를 함께 사용할 때, 언어 간 의 데이터 변환 과정에서 과도한 메모리를 사용했을 수 있다.  
  
##### 18.5.9 익스큐터 OOM 또는 응답 없음  
##### 18.5.10 의도하지 않은 null 값이 있는 결과 데이터  
- 어큐뮬레이터로 정상과 비정상 레코드 수를 확인한다.  
  
##### 18.5.11 디스크 공간 없음 오류  
##### 18.5.12 직렬화 오류  
  
  
#### 18.6 정리 
