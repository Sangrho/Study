## 내부 메커니즘
아래 세 가지 초점으로 살펴본다.
- 카프카 복제가 동작하는 방법
- 카프카가 프로듀서와 컨슈머의 요청을 처리하는 방법
- 카프카가 스토리지(예를 들어, 파일 형식이나 인덱스)를 처리하는 방법

### 클러스터 멤버십

내부적으로 주키퍼는 표준 파일 시스템의 디렉터리처럼 계층적인 트리 구조로 데이터를 저장하고 사용한다.
그리고 데이터를 저장하는 노드를 znode라고 하며, 각 znode의 이름 앞에는 / 를 붙이고 디렉터리처럼 경로를 사용해서 각 노드의 위치를 식별한다.
각 노드에는 상태와 구성 정보 및 위치 정보 등의 데이터만 저장되므로 크기가 작으며(1KB 미만), 모든 노드가 메모리에 저장되어 처리되므로 속도라 빠르다.
그리고 임시(ephemeral) 노드와 영구(persistent) 노드로 구분된다.
임시 노드는 노드를 생성한 클라이언트가 연결되어 있을 때만 존재하며,
연결이 끊어지면 자동으로 삭제된다. 반면 영구 노드는 클라이언트가 삭제하지 않는한 계속 보존된다.</br></br>
카프카에서도 주키퍼를 사용해서 클러스터 멤버인 브로커들의 메타데이터를 유지 관리한다.
예를 들어 아래와 같다</br>

    /kafka-main/brokers : 브로커 관련 정보 저장
    /kafka-main/brokers/ids : 브로커 ID 저장
    /kafka-main/topics : 토픽 정보가 저장
    /kafka-main/config : 토픽의 설정 정보가 저장
    /kafka-main/consumers : 컨슈머의 파티션 오프셋 정보를 저장(0.9 버전부터 __consumer_offsets topic 에 저장되도록 변경됨)

모든 카프카 브로커는 고유 식별자를 가지며, 이것은 브로커의 구성 파일에 설정되거나 자동으로 생성된다.
브로커 프로세스는 시작될 때마다 주키퍼의 /brokers/id 에 임시 노드로 자신의 ID를 등록한다.
만일 같은 ID 를 갖는 다른 브로커를 시작하려고 하면 같은 주키퍼 노드가 이미 있으므로 에러가 발생한다.</br></br>
그리고 브로커 구성에서 브로커가 추가 혹은 삭제되거나 주키퍼와 연결이 끊어지면, 해당 브로커가 시작될 때 생성되었던 임시노드는 자동으로 주키퍼에서 삭제되며,
브로커 내역을 모니터링하는 카프카 컴포넌트들이 알 수 있다.(주키퍼의 Watch 설정)</br></br>
브로커가 중단되면 해당 브로커의 주키퍼 노드는 삭제된다. 그러나 해당 브로커의 ID는 여전히 다른 데이터 구조에 존재한다. 

### 컨트롤러

컨트롤러는 카프카 브로커 중 하나이며, 일반 브로커의 기능에 추가하여 파티션 리더를 선출하는 책임을 갖는다. 
클러스터에서 시작하는 첫 번째 브로커가 컨트롤러가 되며, 이 브로커는 주키퍼의 임시 노드인 /controller를 생성한다.
그리고 다른 브로커들이 시자고딜 때도 /controller 노드를 생성하려고 시도한다.
그러나 '노드가 이미 존재한다' 는 예외를 받으므로,
이미 /controller 노드가 있고 클러스터에도 컨트롤러가 있다는 것을 '알게된다'.
그리고 모든 브로커들은 /controller 노드에 주키퍼의 Watch를 생성하므로 이 노드에 변경이 생기는 것을 알 수 있다.
이런 방법을 통해서 클러스터에는 항상 하나의 컨트롤러만 존재한다.</br></br>
컨트롤러 브로커가 중단되거나 주키퍼와의 연결이 끊어지면 임시 노드인 /controller가 삭제된다.
이때 해당 클러스터의 다른 브로커들이 주키퍼의 Watch를 통해 그 사실을 알게 되고 /controller 노드의 생성을 시도한다.
그리고 그 노드를 첫 번째로 생성한 브로커가 컨트롤러가 되며, 다른 브로커들은 이미 얘기한 대로 '노드가 이미 존재한다'는 예외를 받는다.
또한 모든 브로커가 새소 생성된 /controller 노드에 주키퍼의 Watch를 생성한다.
컨트롤러는 매번 새로 선출될 때마다 주키퍼로부터 새로운 컨트롤러 세대 번호를 받으며,
나머지 브로커들은 현재의 컨트롤러 세대 번호를 알게 된다.
따라서 변경 전의 컨트롤러와 혼동되지 않으며, 이전 세대 번호로 된 컨트롤러 메세지를 받으며 무시한다.</br></br>
관련 주키퍼 경로를 Watch하여 특정 브로커가 클러스터를 떠났다는 것을 컨트롤러가 인지하면, 그 브로커가 리더로 할당되었던 모든 파티션들에
새로운 리더가 필요하다는 것을 알게 된다. 그 다음에 컨트롤러는 새로운 리더를 필요로 하는 모든 파티션들을 점검하고 새로 리더가 될 브로커를 결정한다.(간단히 해당 파티션의 리플리카 리스트에서 그 다음 순서의 브로커로 결정함).
그리고 컨트롤러는 파티션들의 새로운 리더들과 팔로워들의 정보를 모든 브로커들에게 전송한다.</br></br>
새로 결정된 각 파티션의 리더는 프로듀서와 컨슈머의 요청 처리를 시작해야 한다는 것을 알고 있으며, 팔로워들은 새로운 리더의 메세지 복제를 시작해야 한다는 것을 안다.</br></br>
새 브로커가 클러스터에 추가되면 컨트롤러는 브로커 ID를 사용해서 그 브로커의 리플리카로 사용할 브로커가 있는지 확인한다. 만일 있으면 컨트롤러는 새 브로커와 기존 브로커 모두에게 변경 사항을 알리며, 새 브로커의 리플리카들은 기존 리더들의 메세지를 복제하기 시작한다.</br></br>

### 복제

복제는 카프카 아키텍처의 핵심이다. 각 서버 노드에 장애가 생길 때 카프카가 가용성과 내구성을 보장하는 방법이기 때문이다. </br></br>리플리카에는 아래와 같이 두 가지 형태가 있다.

    * 리더 리플리카
        각 파티션은 리더로 지정된 하나의 리플리카를 갖는다. 일관성을 보장하기 위해 모든 프로듀서와 컨슈머 클라이언트의 요청은 리더를 
        통해서 처리된다.
    
    * 팔로워 리플리카
        각 파티션의 리더를 제외한 나머지 리플리카를 팔로워라고 한다. 팔로워는 클라이언트요청을 서비스하지 않는다. 
        대신에 리더의 메세지를 복제하여 리더의 것과 동일하게 유지한다. 그리고 특정 파티션의 리더 리플리카가 중단되는 경우에는 
        팔로워 리플리카 중 하나가 해당 파티션의 새로운 리더로 선출된다.

리더는 팔로워 리플리카 중에 어느 것이 최신의 리더 메세지를 복제하고 있는지 알아야 한다.
팔로워들은 리더가 받는 모든 최신 메세지를 복제하려고 한다.
그러나 여러 가지 이유로 동기화에 실패할 수 있다. 예를 들어, 네트워크의 혼잡으로 인해 복제가 늦어지는 경우다.
또는 브로커가 중단되어 해당 브로커를 시작시킨 후 다시 복제를 시작할 수 있을 때까지 해당 브로커의 모든 리플리카들의 복제가 늦어지게 되는 경우다.</br></br>
리더와 동기화를 하기 위해 리플리카들은 리더에게 Fetch 요청을 전송한다. 이것은 컨슈머가 메세지를 읽기 위해 전송하는 것과 같은 타입의 요청이다.
그리고 그런 요청의 응답으로 리더는 리플리카들에게 메세지를 전송한다.
Fetch 요청에는 리플리카가 다음으로 받기 원하는 메세지의 오프셋이 포함되며, 항상 수신된 순서대로 처리된다.</br></br>
이와는 반대로, 최신 메세지를 계속 요청하는 팔로워 리플리카를 동기화 리플리카(in-sync replica, ISR) 라고 한다. 기존 리더가 중단되는 경우 동기화 리플리카만이 리더로 선출될 수 있다.</br></br>
동기화되지 않는다고 간주되기 전에, 팔로워가 비활성 상태가 될 수 있는 지연 시간은 replica.lag.time.max.ms 구성 매개변수로 제어할 수 있다.
이 지연시간은 리더를 선출하는 동안의 클라이언트 실행과 데이터 보존에 영향을 준다.</br></br>
현재 리더에 추가하여 각 파티션은 선호 리더를 갖는다. 이것은 토픽이 생성될 때 각 파티션의 리더였던 리플리카들을 말한다.
하나의 토픽은 여러 개의 파티션으로 구성될 수 있으며, 파티션들을 처음 생성할 때는 여러 브로커가 고르게 파티션을 할당받아 리더가 되므로
이것이 선호되는 리더들이다. 결론적으로, 선호 리더들이 클러스터의 모든 파티션 리더들일 때는 브로커 간의 파티션 배분이 고르게 된다. 기본적으로 카프카는 auto.leader,rebalance.enable=true 로 구성된다. 이 경우 선호 리더 리플리카가 현재 리더느 ㄴ아닐 경우 동기화 리플리카인지 확인한다. 그리고 리더를 선출할 때 선호 리더를 현재 리더로 선출한다.</br></br>

    선호 리더 찾기
        파티션의 리플리카 내역을 보면 

### 요청 처리

#### 쓰기 요청

#### 읽기 요청

#### 기타 요청


### 스토리지

#### 파티션 할당

#### 파일 관리
#### 파일 형식

#### 인덱스

#### 압축

#### 압축 처리 방법

#### 삭제된 메세지

#### 토픽은 언제 압축될까?


Referenced from Kafka The definitive guide
